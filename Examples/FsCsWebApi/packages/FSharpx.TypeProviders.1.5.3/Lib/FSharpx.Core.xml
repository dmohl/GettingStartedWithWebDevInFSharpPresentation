<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpx.Core</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.BS.GetHashCode">
<summary>
 Gets the hash code for the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.Equals(System.Object)">
<summary>
 Compares two objects for equality. When both are byte strings, structural equality is used.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.BS.Compare(FSharpx.BS,FSharpx.BS)">
<summary>
 Compares two byte strings based on their structure.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.BS">
<summary>
 An ArraySegment with structural comparison and equality.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DList`1">
<summary>
 The DList is an implementation of John Hughes&apos; append list.
 See http://dl.acm.org/citation.cfm?id=8475 for more information.
 This implementation adds an additional parameter to allow a more
 efficient calculation of the list length.
 Note that an alternate form would represent the DList as:
 type DList&lt;&apos;a&gt; = DList of (&apos;a list -&gt; &apos;a list)
 An example can be found at http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5327209#5327209
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpAsyncExtensions.Protect``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Encapsulates any possible exceptions during bind in a Choice
</summary>
</member>
<member name="M:FSharpx.FSharpAsyncExtensions.IgnoreResult``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Ignores (discards) the result of the async computation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``3(System.Func{``0,``1,``2})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``2(System.Func{``0,``1})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``1(System.Func{``0})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``3(System.Action{``0,``1,``2})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``2(System.Action{``0,``1})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``1(System.Action{``0})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction(System.Action)">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="T:FSharpx.FSharpFunc">
 <summary>
 Conversion functions from Action/Func to FSharpFunc
 We need these because FuncConvert often makes C# type inference fail.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Funcs">
<summary>
 Extensions around Actions and Funcs
</summary>
</member>
<member name="M:FSharpx.L.F``3(System.Func{``0,``1,``2})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``2(System.Func{``0,``1})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``1(System.Func{``0})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="T:FSharpx.L">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.ArrayModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterDot``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequentially compose two async actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiply``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_MultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Async.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Async.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Transforms an async value by using a specified mapping function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.pipe``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Flipped map
</summary>
</member>
<member name="M:FSharpx.Async.ap``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterEquals``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Async.returnM``1(``0)">
<summary>
 Inject a value into the async type
</summary>
</member>
<member name="M:FSharpx.Async.bind``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequentially compose two actions, passing any value produced by the second as an argument to the first.
</summary>
</member>
<member name="T:FSharpx.Async">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.ByteString.append(FSharpx.BS,FSharpx.BS)">
<summary>
 append uses Buffer.BlockCopy for efficient array operations.
 Please note that a new array is created and both arrays are copied in,
 disregarding any additional bytes in the original, underlying arrays.
</summary>
</member>
<member name="M:FSharpx.ByteString.cons(System.Byte,FSharpx.BS)">
<summary>
 cons uses Buffer.SetByte and Buffer.BlockCopy for efficient array operations.
 Please note that a new array is created and both the head and tail are copied in,
 disregarding any additional bytes in the original tail array.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.ByteString.|BS|(FSharpx.BS)">
<summary>
 An active pattern for conveniently retrieving the properties of a BS.
</summary>
</member>
<member name="T:FSharpx.ByteString">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.fromOption``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 If Some value, returns Choice1Of2 value. Otherwise, returns the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Choice.toOption``2">
<summary>
 If Choice is 1Of2, returns Some value. Otherwise, returns None.
</summary>
</member>
<member name="M:FSharpx.Choice.mapSecond``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Transforms a Choice&apos;s second value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.choice``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.bimap``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``3},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpChoice{``3,``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Choice.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``2,``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Choice.bind``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Choice.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Choice.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``3},Microsoft.FSharp.Core.FSharpChoice{``1,``3})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Choice.map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Transforms a Choice&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.cast``1(System.Object)">
<summary>
 Attempts to cast an object.
 Stores the cast value in 1Of2 if successful, otherwise stores the exception in 2Of2
</summary>
</member>
<member name="M:FSharpx.Choice.protect``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``0)">
<summary>
 Wraps a function, encapsulates any exception thrown within to a Choice
</summary>
</member>
<member name="M:FSharpx.Choice.get``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw ArgumentException.
</summary>
</member>
<member name="M:FSharpx.Choice.returnM``2(``0)">
<summary>
 Inject a value into the Choice type
</summary>
</member>
<member name="T:FSharpx.Choice">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation.Coroutine">
<summary>
 The coroutine type from http://fssnip.net/7M
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation.Cont`2">
<summary>
 The continuation monad.
 The algorithm is from Wes Dyer http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
 Current implementation from Matt&apos;s gist at https://gist.github.com/628956
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Continuation.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Continuation.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``3,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Continuation.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequentially compose two continuation actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Continuation.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Continuation.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Continuation.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``3},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``3},``3}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``3},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``3},``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Continuation.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Continuation.map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Transforms a Cont value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Continuation.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Continuation.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Continuation.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Continuation.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Continuation.returnM``2(``0)">
<summary>
 Inject a value into the Cont type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DList.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,FSharpx.DList{``1})">
<summary>
 Fold walks the DList using constant stack space. Implementation is from Norman Ramsey.
 See http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5334068#5334068
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DList">

</member>
<member name="">

</member>
<member name="T:FSharpx.DictionaryModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Distribution.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``0}})">
<summary>
 Transforms a Distribution value by using a specified mapping function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Distribution.returnM``1(``0)">
<summary>
 Inject a value into the Distribution type
</summary>
</member>
<member name="M:FSharpx.Distribution.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``1}}},System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``0}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Distribution.op_GreaterGreaterEquals``2(System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``0}},Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Collections.Generic.IEnumerable{FSharpx.Distribution.Outcome{``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Distribution">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Enumerator.scanUntil``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state until the provided predicate is true.
</summary>
</member>
<member name="M:FSharpx.Enumerator.scanWhile``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state while the provided predicate is true.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Enumerator.scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Enumerator">

</member>
<member name="M:FSharpx.IO.combinePaths(System.String,System.String)">
<summary>
 Combines two path strings
</summary>
</member>
<member name="P:FSharpx.IO.directorySeparator">
<summary>
 The directory separator string. On most systems / or \
</summary>
</member>
<member name="M:FSharpx.IO.appendFileNamesIfNotNull(System.Collections.Generic.IEnumerable{System.String},System.Text.StringBuilder)">
<summary>
 Appends all notnull fileNames
</summary>
</member>
<member name="M:FSharpx.IO.appendStringIfValueIsNotNullOrEmpty(System.String)">
<summary>
 Appends a text if the value is not null or empty
</summary>
</member>
<member name="M:FSharpx.IO.appendStringIfValueIsNotNull``1(``0)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.appendIfNotNull``1(``0,System.String)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.appendIfFalse(System.Boolean)">
<summary>
 Appends a text if the predicate is false
</summary>
</member>
<member name="M:FSharpx.IO.appendIfTrue(System.Boolean,System.String,System.Text.StringBuilder)">
<summary>
 Appends a text if the predicate is true
</summary>
</member>
<member name="M:FSharpx.IO.append(System.String,System.Text.StringBuilder)">
<summary>
 Appends a text
</summary>
</member>
<member name="M:FSharpx.IO.convertTextToWindowsLineBreaks(System.String)">
<summary>
 Converts the given text from linux or mac linebreaks to windows line breaks
</summary>
</member>
<member name="M:FSharpx.IO.replaceFile(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Replaces the file with the given string
</summary>
</member>
<member name="M:FSharpx.IO.writeStringToFile(System.Boolean,System.String,System.String)">
<summary>
 Writes a single string to a file
</summary>
</member>
<member name="M:FSharpx.IO.writeToFile(System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Writes a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.readFile(System.String)">
<summary>
 Reads a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.readFileAsString(System.String)">
<summary>
 Reads a file as one text
</summary>
</member>
<member name="M:FSharpx.IO.allFilesExist(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks if all given files exists
</summary>
</member>
<member name="M:FSharpx.IO.checkFileExists(System.String)">
<summary>
 Checks if the file exists on disk.
</summary>
</member>
<member name="P:FSharpx.IO.currentDirectory">
<summary>
 Gets the current directory
</summary>
</member>
<member name="M:FSharpx.IO.filesInDir(System.IO.DirectoryInfo)">
<summary>
 Gets all files in the directory
</summary>
</member>
<member name="M:FSharpx.IO.subDirectories(System.IO.DirectoryInfo)">
<summary>
 Gets all subdirectories
</summary>
</member>
<member name="M:FSharpx.IO.getFullName(System.String)">
<summary>
 Converts a file to it&apos;s full file system name
</summary>
</member>
<member name="M:FSharpx.IO.fileSystemInfo(System.String)">
<summary>
 Creates a FileInfo or a DirectoryInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.fileInfo(System.String)">
<summary>
 Creates a FileInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.directoryInfo(System.String)">
<summary>
 Creates a DirectoryInfo for the given path
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.IO">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Enumeratee`3">
<summary>
 An enumeratee is an enumerator that produces an iteratee using another iteratee as input.
 Enumeratees can be used for tasks such as encoding or encrypting data.
</summary>
</member>
<member name="T:FSharpx.Iteratee.Enumerator`2">
<summary>
 An enumerator generates a stream of data and feeds an iteratee, returning a new iteratee.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Iteratee`2">
<summary>
 The iteratee is a stream consumer that will consume a stream of data until either 
 it receives an EOF or meets its own requirements for consuming data. The iteratee
 will return Continue whenever it is ready to receive the next chunk. An iteratee
 is fed data by an Enumerator, which generates a Stream. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Stream`1">
<summary>
 A stream of chunks of data generated by an Enumerator.
 The stream can be composed of chunks of &apos;a, empty blocks indicating a wait, or an EOF marker.
 Be aware that when using #seq&lt;_&gt; types, you will need to check for both Seq.empty ([]) and Empty.
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,FSharpx.Iteratee.Iteratee{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,FSharpx.Iteratee.Iteratee{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``2,FSharpx.Iteratee.Iteratee{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_GreaterGreaterDot``3(FSharpx.Iteratee.Iteratee{``0,``1},FSharpx.Iteratee.Iteratee{``0,``2})">
<summary>
 Sequentially compose two iteratee actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_LessMultiply``3(FSharpx.Iteratee.Iteratee{``0,``1},FSharpx.Iteratee.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_MultiplyGreater``3(FSharpx.Iteratee.Iteratee{``0,``1},FSharpx.Iteratee.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Iteratee.ap``3(FSharpx.Iteratee.Iteratee{``0,``1},FSharpx.Iteratee.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Iteratee.op_LessMultiplyGreater``3(FSharpx.Iteratee.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},FSharpx.Iteratee.Iteratee{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Binary">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Iteratee.Primitives">

</member>
<member name="T:FSharpx.Iteratee">

</member>
<member name="">

</member>
<member name="M:FSharpx.LensModule.listToArray``2(FSharpx.Lens{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Converts a lens that views a list into a lens that views an array
</summary>
</member>
<member name="M:FSharpx.LensModule.xmap``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``0},FSharpx.Lens{``2,``0})">
<summary>
 Applies an isomorphism to the value viewed through a lens
</summary>
</member>
<member name="M:FSharpx.LensModule.seqMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a sequence
</summary>
</member>
<member name="M:FSharpx.LensModule.arrayMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in an array
</summary>
</member>
<member name="M:FSharpx.LensModule.listMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a list
</summary>
</member>
<member name="M:FSharpx.LensModule.forList``1(System.Int32)">
<summary>
 Lens for a particular position in a list
</summary>
</member>
<member name="M:FSharpx.LensModule.forArray``1(System.Int32)">
<summary>
 Lens for a particular position in an array
</summary>
</member>
<member name="M:FSharpx.LensModule.forMap``2(``0)">
<summary>
 Lens for a particular key in a map
</summary>
</member>
<member name="M:FSharpx.LensModule.forSet``1(``0)">
<summary>
 Lens for a particular value in a set
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.LensModule.id``1">
<summary>
 Identity lens
</summary>
</member>
<member name="M:FSharpx.LensModule.snd``2">
<summary>
 Gets/sets the snd element in a pair
</summary>
</member>
<member name="M:FSharpx.LensModule.fst``2">
<summary>
 Gets/sets the fst element in a pair
</summary>
</member>
<member name="M:FSharpx.LensModule.modifyAndGetState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the modified value.
</summary>
</member>
<member name="M:FSharpx.LensModule.getAndModifyState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the original value.
</summary>
</member>
<member name="M:FSharpx.LensModule.updateState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1},``0)">
<summary>
 Update through a lens within a state monad
</summary>
</member>
<member name="M:FSharpx.LensModule.setState``2(FSharpx.Lens{``0,``1},``1,``0)">
<summary>
 Applies a lens in the &apos;set&apos; direction within a state monad
</summary>
</member>
<member name="M:FSharpx.LensModule.getState``2(FSharpx.Lens{``0,``1},``0)">
<summary>
 Applies a lens in the &apos;get&apos; direction within a state monad      
</summary>
</member>
<member name="M:FSharpx.LensModule.cond``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},FSharpx.Lens{``0,``1},FSharpx.Lens{``0,``1})">
 <summary>
 <paramref name="pred"/> is applied to source. 
 If true, <paramref name="lensTrue"/> is selected.
 If false, <paramref name="lensFalse"/> is selected.
 </summary>
</member>
<member name="M:FSharpx.LensModule.pair``4(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``3})">
<summary>
 Pair two lenses
</summary>
</member>
<member name="M:FSharpx.LensModule.choice``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``1})">
<summary>
 Composes two lenses through a sum in the source
</summary>
</member>
<member name="M:FSharpx.LensModule.compose``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``0})">
<summary>
 Sequentially composes two lenses
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.LensModule.StateOperators">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.LensModule.Operators">

</member>
<member name="T:FSharpx.LensModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.List.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Curried cons
</summary>
</member>
<member name="T:FSharpx.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.OptionMonoid`1">
<summary>
 Option wrapper monoid
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.ListMonoid`1">
<summary>
 List monoid
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid.Monoid`1.mconcat(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Fold a list using this monoid
 </summary>
</member>
<member name="M:FSharpx.Monoid.Monoid`1.mappend(`0,`0)">
 <summary>
 Associative operation
 </summary>
</member>
<member name="P:FSharpx.Monoid.Monoid`1.mempty">
 <summary>
 Identity
 </summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.Monoid`1">
<summary>
 Monoid (associative binary operation with identity)
 The monoid implementation comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="P:FSharpx.Monoid.IntProductMonoid">
<summary>
 Monoid (int,1,*)
</summary>
</member>
<member name="P:FSharpx.Monoid.IntSumMonoid">
<summary>
 Monoid (int,0,+)
</summary>
</member>
<member name="T:FSharpx.Monoid">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.NameValueCollectionModule.fromSeq(System.Collections.Generic.IEnumerable{System.Tuple`2{System.String,System.String}})">
 <summary>
 Creates a <see cref="NameValueCollection"/> from a list of key-value pairs
 </summary>
 <param name="l"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.toList(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as a list of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.ToEnumerable(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as a sequence of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.add(System.String,System.String,System.Collections.Specialized.NameValueCollection)">
<summary>
 Adds an element to a copy of an existing NameValueCollection
</summary>
</member>
<member name="M:FSharpx.NameValueCollectionModule.addInPlace(System.Collections.Specialized.NameValueCollection,System.String,System.String)">
 <summary>
 In-place add of a key-value pair to a <see cref="NameValueCollection"/>
 </summary>
 <param name="x"></param>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.Concat(System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a new <see cref="NameValueCollection"/> with the concatenation of two <see cref="NameValueCollection"/>s
 </summary>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="T:FSharpx.NameValueCollectionModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Nullable.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Nullable.toList``1(System.Nullable{``0})">
<summary>
 Convert the nullable to a list of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.toArray``1(System.Nullable{``0})">
<summary>
 Convert the nullable to an array of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},System.Nullable{``0})">
<summary>
 Transforms a Nullable value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Nullable.iter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},System.Nullable{``0})">
<summary>
 Executes a function for a nullable value.
</summary>
</member>
<member name="M:FSharpx.Nullable.forall``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.forall for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.exists``1(Microsoft.FSharp.Core.FSharpFunc`2{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.exists for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.foldBack``2(Microsoft.FSharp.Core.FSharpFunc`2{System.Nullable{``0},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1}},System.Nullable{``0},``1)">
<summary>
 Performs the equivalent of the List.foldBack operation on a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.Nullable{``1})">
<summary>
 Evaluates the equivalent of List.fold for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.count``1(System.Nullable{``0})">
<summary>
 Returns 1 if Nullable has value, otherwise 0
</summary>
</member>
<member name="M:FSharpx.Nullable.isNull``1(System.Nullable{``0})">
<summary>
 True if Nullable does not have value
</summary>
</member>
<member name="M:FSharpx.Nullable.hasValue``1(System.Nullable{``0})">
<summary>
 True if Nullable has value
</summary>
</member>
<member name="M:FSharpx.Nullable.bind``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Nullable{``1}},System.Nullable{``0})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Nullable.toOption``1">
<summary>
 Converts nullable to option
</summary>
</member>
<member name="M:FSharpx.Nullable.fromOption``1">
<summary>
 Converts option to nullable
</summary>
</member>
<member name="M:FSharpx.Nullable.get``1(System.Nullable{``0})">
<summary>
 Gets the value associated with the Nullable.
 If no value, throws.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrElse``1(System.Nullable{``0},System.Lazy{``0})">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrDefault``1(System.Nullable{``0},``0)">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Nullable">

</member>
<member name="M:FSharpx.Operators.applyM``7(``0,``5,``1,``6)">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Operators.returnM``3(``0,``1)">
<summary>
 Inject a value into the monadic type
</summary>
</member>
<member name="T:FSharpx.Operators">
<summary>
 Generic monadic operators    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Option.MaybeBuilder">
<summary>
 The maybe monad.
 This monad is my own and uses an &apos;a option. Others generally make their own Maybe&lt;&apos;a&gt; type from Option&lt;&apos;a&gt;.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Option.Cast``1(System.Object)">
<summary>
 Attempts to cast an object. Returns None if unsuccessful.
</summary>
</member>
<member name="M:FSharpx.Option.filter``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Applies a predicate to the option. If the predicate returns true, returns Some x, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.orElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the option if Some x, otherwise the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrDefault``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the default value for the type.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseF``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value from a function.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseLazy``1(System.Lazy{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElse``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.fromChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Maps Choice 1Of2 to Some value, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.fromBoolAndValue``1(System.Boolean,``0)">
<summary>
 If true,value then returns Some value. Otherwise returns None.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.tryParseWith``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Tuple`2{System.Boolean,``1}})">
<summary>
 Converts a function returning bool,value to a function returning value option.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.fromBool(System.Boolean)">
<summary>
 True -&gt; Some(), False -&gt; None
</summary>
</member>
<member name="M:FSharpx.Option.toNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Maps an Option to Nullable
</summary>
</member>
<member name="M:FSharpx.Option.fromNullable``1(System.Nullable{``0})">
<summary>
 Maps a Nullable to Option
</summary>
</member>
<member name="M:FSharpx.Option.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequentially compose two maybe actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Option.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Option.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Option.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Option.ap``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Option.returnM``1(``0)">
<summary>
 Inject a value into the option type
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Prelude.tuple6``6(``0,``1,``2,``3,``4,``5)">
<summary>
 Creates a 6-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple5``5(``0,``1,``2,``3,``4)">
<summary>
 Creates a 5-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple4``4(``0,``1,``2,``3)">
<summary>
 Creates a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple3``3(``0,``1,``2)">
<summary>
 Creates a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple2``2(``0,``1)">
<summary>
 Creates a pair
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Prelude">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader.ReaderBuilder">
<summary>
 The reader monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/07/much-ado-about-monads-reader-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Reader.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequentially compose two reader actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Reader.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Reader.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``3,``0},Microsoft.FSharp.Core.FSharpFunc`2{``3,``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Reader.map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,``0})">
<summary>
 Transforms a Reader value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Reader.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``1,``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``0,``2}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Reader.returnM``2(``0)">
<summary>
 Inject a value into the Reader type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.RegexModule.tryMatchWithOptions(System.Text.RegularExpressions.RegexOptions,System.String,System.String)">
<summary>
flags:RegexOptions -&gt; pattern:string -&gt; input:string -&gt; Regex.ActiveMatch option
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.RegexModule.Interpreted">

</member>
<member name="">

</member>
<member name="T:FSharpx.RegexModule.Compiled">

</member>
<member name="T:FSharpx.RegexModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.Seq.tryFindWithIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Returns the first element (with its index) for which the given function returns true.
 Return None if no such element exists.
 </summary>
 <param name="pred">Predicate</param>
 <param name="l">Sequence</param>
</member>
<member name="M:FSharpx.Seq.index``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Adds an index to a sequence
 </summary>
 <param name="a"></param>
</member>
<member name="T:FSharpx.Seq">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State.StateBuilder">
<summary>
 The state monad.
 The algorithm is adjusted from my original work off of Brian Beckman&apos;s http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/.
 The approach was adjusted from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2009/12/30/much-ado-about-monads-state-edition.aspx and mirrors his final result.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.State.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``1,``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``3,``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.State.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.State.lift2``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``3,System.Tuple`2{``0,``3}},Microsoft.FSharp.Core.FSharpFunc`2{``3,System.Tuple`2{``1,``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.State.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.State.map``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Transforms a State value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.State.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2}},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.State.returnM``2(``0)">
<summary>
 Inject a value into the State type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.ListQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.ArrayQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core">

</member>
<member name="T:FSharpx.Stm">
 <summary>The Software Transactional Memory monad.</summary>
 <see href="http://cs.hubfs.net/blogs/hell_is_other_languages/archive/2008/01/16/4565.aspx" />
</member>
<member name="M:FSharpx.Strings.isNullOrEmpty(System.String)">
<summary>
 Returns if the string is null or empty
</summary>
</member>
<member name="M:FSharpx.Strings.separatedBy(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a single string separated with the delimiters
</summary>
</member>
<member name="M:FSharpx.Strings.split(System.Char,System.String)">
<summary>
 Splits the given string at the given delimiter
</summary>
</member>
<member name="M:FSharpx.Strings.contains(System.String,System.String)">
<summary>
 Returns a value indicating whether the specified substring occurs within this string
</summary>
</member>
<member name="M:FSharpx.Strings.replace(System.String,System.String,System.String)">
<summary>
 Replaces the given &quot;replacement&quot; for every occurence of the pattern in the given text 
</summary>
</member>
<member name="M:FSharpx.Strings.startsWith(System.String,System.String)">
<summary>
 Checks whether the given text starts with the given prefix
</summary>
</member>
<member name="T:FSharpx.Strings">

</member>
<member name="M:FSharpx.TimeMeasurement.stopAverageTime``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopTime``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the runtime for a given function
</summary>
</member>
<member name="T:FSharpx.TimeMeasurement">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Undo">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.CustomValidation`1.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apr``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apl``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.ap``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.op_LessMultiply``2">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.op_MultiplyGreater``2">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.lift2``3">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.ap``2">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.apm``3(FSharpx.Monoid.Monoid{``0})">
<summary>
 Sequential application, parameterized by monoid
</summary>
</member>
<member name="M:FSharpx.Validation.apa``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Core.FSharpChoice{``1,``0},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},``0})">
<summary>
 Sequential application, parameterized by append
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Validation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Writer.WriterBuilder`1">
<summary>
 The writer monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``2,Microsoft.FSharp.Collections.FSharpList{System.String}}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Writer.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Writer.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Writer.map``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Transforms a Writer value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Writer.ap``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.returnM``2(FSharpx.Monoid.Monoid{``0},``1,Microsoft.FSharp.Core.Unit)">
<summary>
 Inject a value into the Writer type
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Writer">

</member>
<member name="M:FSharpx.ZipList.op_LessMultiply``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.op_MultiplyGreater``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.lift2``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.ZipList.ap``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ZipList.op_LessMultiplyGreater``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.ZipList">

</member>
</members>
</doc>
